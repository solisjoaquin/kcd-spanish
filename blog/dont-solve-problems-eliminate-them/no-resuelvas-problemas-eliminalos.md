No resuelvas problemas, elim√≠nalos
====================================

![Software Engineer, React Training, Testing JavaScript Training](https://res.cloudinary.com/kentcdodds-com/image/upload/v1620771700/kentcdodds.com/blog/don-t-solve-problems-eliminate-them/banner_qzwcgj.jpg)

Foto por [Jordan Whitt](https://unsplash.com/photos/EerxztHCjM8)

*Como eliminar problemas puede simplificar dr√°sticamente tus bases de c√≥digo y tu vida*

Los seres humanos somos solucionadores de problemas por naturaleza. El hecho de que hayamos sobrevivido tanto tiempo como especie lo comprueba.

Los seres humanos tambi√©n somos buscadores de problemas naturales. Pi√©nsalo por un momento...Y no estoy hablando de *"los otros"*. Estoy hablando de ti y de m√≠ tambi√©n. Es dif√≠cil y se necesita hacer un esfuerzo consciente para evitarlo. Pasamos tanto tiempo resolviendo problemas, que naturalmente buscamos problemas para resolver, incluso si no tenemos problemas en este momento. 

![Photo of a Violin by Providence Doucet](https://res.cloudinary.com/kentcdodds-com/image/upload/f_auto,q_auto,dpr_2.0/v1620774892/kentcdodds.com/blog/don-t-solve-problems-eliminate-them/violin_pdtl8b.jpg)

Por ejemplo, una de mis hermanas me pregunto si pod√≠a ayudarla a crear una aplicaci√≥n que combinara las capacidades de Zoom, Tito y Google Calendar para permitir que los m√∫sicos sin trabajo (debido a la pandemia) pudieran ense√±ar sus habilidades de manera remota. Ella estaba buscando problemas para resolver antes de siquiera tener problemas.

En lugar de ayudarla a crear soluciones a problemas que a√∫n no ten√≠a, la anim√© a que simplemente *usara* Zoom, Tito y Google Calendar para hacer que esta idea despegara, y luego, en el momento que estas herramientas se quedaran cortas, esto ser√≠a un problema para el cual estar√≠a mejor preparada para resolver, ya que tendr√≠a experiencia real con el problema y, por lo tanto, tendr√≠a m√°s contexto para resolverlo.

Al final, mi hermana decidi√≥ no seguir con su idea. Es bueno que no haya decidido resolver los problemas que no ten√≠a antes de decidirse a dejar la idea. Ojal√° pudiera decir que nunca he cometido ese error. ¬øCu√°ntas veces he escrito una prueba para una pieza de c√≥digo que al final termin√© eliminando siquiera antes de hacerle *"commit"*? ü§¶‚Äç‚ôÇÔ∏è

**Evitar problemas es mejor que resolverlos.** No intentes resolver problemas que a√∫n no tienes. Y con esto no estoy diciendo que no deber√≠as de planear con anticipaci√≥n. Puedes evitar resolver problemas que no tienes sin tener que arrinconarte a ti mismo en una esquina.


Problemas inevitables
------------------------------------------------------------------------------------------------------------
Aunque evitar un problema es lo mejor, a veces esto no es posible. ¬øY entonces que hacemos en este caso?

Los humanos **deber√≠an** ser eliminadores de problemas. Esto no es natural y requiere un esfuerzo adicional. Cuando nos enfrentamos a un problema, los humanos naturalmente comenzamos a pensar en soluciones al problema. Y cuando lo resolvemos, nos sentimos bien con nosotros mismos, pero sin darnos cuenta nos hemos hecho **cautivos del mantenimiento de nuestra soluci√≥n** ‚õì

Sin embargo, si alguien puede dar un paso hacia atr√°s y eliminar el problema en lugar de resolverlo, se encontrar√° en una excelente posici√≥n, liberado para entonces concentrarse en tareas distintas de mantener las soluciones. Y, a menudo, los problemas tambi√©n se eliminan para las personas que utilizan lo estos eliminadores de problemas producen.

A continuaci√≥n consideremos algunos ejemplos:

Eliminaci√≥n de problemas en la vida real
------------------------------------------------------------------------------------------------------------------------------

[![Tesla Model S driving fast with mountains in the background](https://res.cloudinary.com/kentcdodds-com/image/upload/f_auto,q_auto,dpr_2.0/v1620774548/kentcdodds.com/blog/don-t-solve-problems-eliminate-them/tesla_model_s_mbupt9.jpg)](https://tesla.com/s)

Tesla es un buen ejemplo de esto. Al ser 100% el√©ctricos han logrado eliminar un sinf√≠n de partes y procesos que hab√≠an sido est√°ndar en la industria durante d√©cadas. Esto los ha liberado para ellos entonces poder concentrarse en su enfoque alternativo.

Como due√±o de un carro el√©ctrico, haber cambiado de motor de combusti√≥n interna a un motor el√©ctrico me ha permitido eliminar problemas como "¬ød√≥nde le realizo el cambio de aceite a mi motor?", o preocupaciones de que quiz√°s la trasmisi√≥n se va a estropear, las pastas de freno requieren cambio, y un largo etc√©tera. (Esto se debe a que los carros el√©ctricos requieren menos mantenimiento debido a que tienen una cantidad inferior de partes comparados con los carros tradicionales de combusti√≥n interna)

[![Screenshot of a tesla livestream showing the model y giga casting machine with the words "40% rear underbody cost savings" and "-79 parts per car"](https://res.cloudinary.com/kentcdodds-com/image/upload/f_auto,q_auto,dpr_2.0/v1620835374/kentcdodds.com/blog/don-t-solve-problems-eliminate-them/giga_casting_dymoig.png)](https://youtu.be/l6T9xIeZTds?t=4767) 
(40% de ahorro en costos en el cuerpo inferior) | (79 partes menos por carro)

Una de las innovaciones m√°s recientes de Tesla es el uso de la "Gigapress (la gigantoprensa)" la cual les permite forjar enteramente la parte trasera o delantera del veh√≠culo a partir de una sola pieza 
(en los carros tradicionales esto se hace en diferentes secciones y requiere muchas piezas). Este proceso elimina la necesidad de tener docenas de robots que est√©n atornillando y soldando las piezas unas a otras.

Tesla es un fant√°stico ejemplo de eliminaci√≥n de problemas. Un caso para estudiar para cualquier persona que est√© interesada en la manufactura a gran escala. La eliminaci√≥n de problemas es un factor decisivo de gran √©xito.

Programando eliminaci√≥n de problemas
------------------------------------------------------------------------------------------------------------------------

La mayor√≠a de los que est√°n leyendo esto probablemente no manufacturamos a gran escala. Probablemente t√∫ desarrolles aplicaciones. Entonces ¬øcu√°les son algunos de los ejemplos de eliminaci√≥n de problemas relacionados con la programaci√≥n? 

[![React logo](https://res.cloudinary.com/kentcdodds-com/image/upload/f_auto,q_auto,dpr_2.0/v1620775101/kentcdodds.com/blog/don-t-solve-problems-eliminate-them/react_nlj9aq.png)](https://reactjs.org/)

Hace algunos a√±os, para poder crear un componente en React, necesit√°bamos crear una clase que `"extiende React.Component"`. Agregar√≠amos m√©todos para diferentes eventos del ciclo de vida que quisi√©ramos manejar. Esto funcion√≥ bien durante algunos a√±os, pero un gran problema con esto era la reutilizaci√≥n del c√≥digo. Una "preocupacion" (o caracter√≠stica) podia tener codigo distribuido en cualquiera o todos los `constructores`, `componentDidMount`, `componentDidUpdate`, `componentWillUnmount`, y `render`. Crear abstracciones reutilizables en cada uno de estos "ciclos de vida" era todo un reto.

El equipo y la comunidad de React propusieron ideas como "Componentes de orden superior" y "par√°metros de renderizado" para resolver estos problemas. Durante mucho tiempo, esto pareci√≥ una soluci√≥n bastante buena. Hubo algunas "asperezas" (problemas de "nesting" y jerarqu√≠as falsas con par√°metros de renderizado o soporte de escritura terrible y direccionamiento indirecto / choques de par√°metros para los HOCs), pero, como comunidad nos hab√≠amos acostumbrado a estos problemas y la soluci√≥n funcionaba bastante bien.

Luego, el equipo de React cambi√≥ el juego por completo e introdujo "hooks" (ganchos). Con los "hooks", la reutilizaci√≥n del c√≥digo es trivial y obvia. Compartes c√≥digo con los hooks de React de la misma manera que compartes c√≥digo en JavaScript vainilla: crea una funci√≥n. Eliminaron por completo el problema, ya no sentimos la frustraci√≥n que nos llev√≥ a los HOCs o los par√°metros de renderizado, excepto en escenarios muy espec√≠ficos.

Otro peque√±o ejemplo: al principio de React, la √∫nica forma oficialmente admitida de obtener "estado" y las funciones de un lugar a otro en React era pasar par√°metros. Esto llev√≥ a una "perforaci√≥n de par√°metros" en la que tienes que canalizar par√°metros a trav√©s de componentes en toda tu aplicaci√≥n. Esto era un gran dolor. Hab√≠a una nota en los documentos sobre una API de "contexto" que exist√≠a, pero se desaconsejaba directamente en los documentos.

Luego, redux entr√≥ en escena y resolvi√≥ la perforaci√≥n de par√°metros (entre otras cosas) y la gente se cambi√≥ a redux r√°pidamente. Redux en realidad *us√≥* la API de "contexto", pero debido a que estaba oculta detr√°s de una librer√≠a, a la gente no le preocupaba la advertencia en los documentos (la mayor√≠a ni siquiera sab√≠a que estaban usando la API de "contexto" indirectamente).

Sin embargo, cuando el "contexto" se volvi√≥ oficial, y cuando los "hooks" lo hicieron mucho m√°s f√°cil de usar, muchas personas descubrieron que el problema principal para el cual estaban usando redux (obtener el "estado" en diferentes partes de su aplicaci√≥n) se hab√≠a eliminado con un enfoque integrado, y elimin√≥ redux a favor del nuevo enfoque.

(Para ser claros, hay otras razones por las que las personas usan redux, pero antes de que el "contexto" fuera oficial, esta fue la principal raz√≥n que llev√≥ a las personas a usar redux).

[![Remix logo](https://res.cloudinary.com/kentcdodds-com/image/upload/f_auto,q_auto,dpr_2.0/v1620776599/kentcdodds.com/blog/don-t-solve-problems-eliminate-them/remix-on-light_har5s6.png)](https://remix.run/)

Remix es otro gran ejemplo de una eliminaci√≥n de problemas. Han adoptado un enfoque completamente diferente para crear aplicaciones con React y han eliminado un mont√≥n de problemas en el proceso.

Las personas que vienen de otros metaframeworks se enamoran r√°pidamente del soporte integrado para el enrutamiento "anidado" (nested). Entre otras cosas, esto elimina el problema de los componentes de dise√±o compartidos. Si conoces la frustraci√≥n, entiendes lo que quiero decir. Si no lo haces ... Que suerte la que tienes.

Debido a que Remix expone una API directa a los encabezados de la cach√© de respuesta, puede tener todos los beneficios principales de los generadores de sitios est√°ticos sin necesidad de realizar reconstrucciones incrementales "inteligentes" (que es una soluci√≥n enormemente compleja para un problema real que enfrenta el enfoque SSG).

Debido a la forma en que Remix te permite cargar sus datos en una funci√≥n `loader` en el mismo archivo que tu componente, se elimina el problema de la obtenci√≥n de datos en exceso (simplemente filtras lo que no necesita en el` loader` as√≠ que solo env√≠as lo que se necesita por cable) y se elimina un gran problema que lleva a las personas a usar clientes graphql (para ser claros, Remix funciona con graphql, simplemente no tienes que usar un cliente graphql complejo del lado del cliente con Remix para evitar buscar m√°s de lo necesario). Remix tambi√©n solo hace peticiones (fetch) de los datos de los *dise√±os cambiados* en una transici√≥n de p√°gina (algo que realmente solo puede hacer con el enrutamiento anidado), lo que elimina a√∫n m√°s el problema de b√∫squeda excesiva.

Ya que Remix admite `<form>` directamente, no tienes que preocuparte por el canto y el baile de "form state manager" y "form submission". Y para obtener los mismos beneficios con el enrutamiento del lado del cliente, expone un componente `<Form>` que emula la misma experiencia sin una actualizaci√≥n de p√°gina completa.

Debido a que Remix hace un "re-call" a tus "loaders" en caso de cambios, no necesitas preocuparte por la invalidaci√≥n del cach√©.

Adicionalmente debido a que Remix te permite especificar las etiquetas("tags") de `link` incluidas, ruta por ruta, no necesitas preocuparte porque los cambios de CSS en una p√°gina puedan afectar a los de otra p√°gina. Ese problema se ha eliminado por completo y ahora tal vez lo puedas pensar dos veces antes de utilizar a una librer√≠a CSS-in-JS para resolver este problema. Porque el problema simplemente no existe cuando se usa Remix.

Debido a que Remix es un "framework" enfocado en la mejora progresiva, no necesitas preocuparte por si tu aplicaci√≥n funcionar√° en una red poco confiable donde el JS no se carga por alguna raz√≥n.

Debido a que Remix se basa principalmente en las "web-based API", han eliminado m√°s de la mitad de la documentaci√≥n que de otro modo necesitar√≠an escribir porque solo necesitan indicarte revisar los [MDN](https://developer.mozilla.org/). Y han eliminado el problema de las habilidades transferibles para nosotros como usuarios porque cuanto mejor nos volvemos en Remix, tambi√©n mejoramos en la creaci√≥n de sitios web sin √©l.


Los "trade-offs" (compromisos o "sacrificios")
----------------------------------------------------------------------------------------

A estas alturas, probablemente raz√≥n pensando: "Pero Kent...¬°Puede que hayan eliminado algunos problemas, pero tambi√©n introdujeron nuevos problemas!" S√≠, esto es lo que llamamos "trade-offs" (compromisos) y son imposibles de evitar. Incluso la inacci√≥n (la t√©cnica de eliminaci√≥n de problemas m√°s eficiente) tiene ventajas y desventajas.

Es probable que los veh√≠culos el√©ctricos no tengan los quebraderos de cabeza de mantenimiento de los veh√≠culos de combusti√≥n interna tradicionales, pero tampoco se cargan tan r√°pido como se puede "cargar"(llenar el tanque) un autom√≥vil tradicional y no puedes llevar un bid√≥n de gasolina contigo en caso de quedarte sin carga.


Los "hooks" de React simplificaron dr√°sticamente la reutilizaci√≥n de c√≥digo, pero ahora tienes que aprender sobre la identidad de valor y la memorizaci√≥n cuando construyes esas abstracciones (aunque, a menudo [poniendo cosas dentro del `useEffect`](https://epicreact.dev/memoization-and-react/), podemos eliminar ese problema).

El objetivo final es que los nuevos problemas que tienes que afrontar sean m√°s f√°ciles/econ√≥micos de resolver que los que ten√≠as antes.

**Elimina grandes problemas a cambio de peque√±os problemas.**

Conclusi√≥n
----------------------------------------------------------------------------------------

Hay innumerables ejemplos de eliminaci√≥n de problemas a lo largo de la historia y en todas y cada una de las industrias que han llevado nuestro mundo a un nivel m√°s alto.

Quiero animarlos a todos a aceptar y adherirse a la soluci√≥n de problemas de la humanidad. Tambi√©n quiero que seamos conscientes, retrocedamos un paso y nos preguntemos si estamos resolviendo los problemas correctos. ¬øEstamos simplemente resolviendo problemas que creamos a partir de la soluci√≥n de otros problemas? ¬øEs posible eliminar esos primeros problemas para que no tengamos que resolver los problemas que cre√≥ nuestra soluci√≥n?

**Empieza por no buscar problemas. Si realmente tienes un problema, primero intenta eliminarlo de ser posible, y solo resu√©lvelo si est√°s seguro de que no se puede eliminar.**

El mayor desaf√≠o es asegurarnos de que nuestra eliminaci√≥n de problemas no cree problemas mayores. Pero cuando logres hacer esto, puedes mejorar dr√°sticamente las cosas para ti y para todos los que disfrutan de lo que has creado. ¬°Arri√©sgate, comete errores y elimina problemas!

[2021-05-11](https://github.com/kentcdodds/kentcdodds.com/commits/main/content/blog/don-t-solve-problems-eliminate-them/index.mdx)

traducido por: @dani1995ar